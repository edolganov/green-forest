Is used to specify a named query in the Java Persistence query language, which is a static query expressed in metadata. Query names are scoped to the persistence unit. 
The following is an example of the definition of a named query in the Java Persistence query language: 

    @NamedQuery(
            name="findAllCustomersWithName",
            query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
    )
 
The following is an example of the use of a named query: 

    @PersistenceContext
    public EntityManager em;
    ...
    customers = em.createNamedQuery("findAllCustomersWithName")
            .setParameter("custName", "Smith")
            .getResultList();




http://onjava.com/onjava/2005/07/20/transactions.html

			Get TransactionManager Directly from JNDI (JBoss, WebLogic)

			In JBoss 3 and WebLogic 8, TransactionManager is available in JNDI, albeit under different names, and therefore can be obtained by simple lookup:
			private TransactionManager getFromJNDI() 
					throws Exception {
				InitialContext ctx = new InitialContext();
				try {
					// WebLogic
					return (TransactionManager)
						ctx.lookup("javax.transaction.TransactionManager");
				 }
				 catch (Exception e) {  }

				try {
					// JBoss
					return (TransactionManager)
						ctx.lookup("java:/TransactionManager");
				}
				catch (Exception e) { }
				return null;
			}



http://onjava.com/pub/a/onjava/2005/07/20/transactions.html?page=2

			// obtain UserTransaction object and start transaction
			InitialContext ctx = new InitialContext();
			UserTransaction userTransaction = (UserTransaction)
				ctx.lookup("java:comp/UserTransaction");

			// start first transaction
			userTransaction.begin();
						
			// obtain TransactionManager 
			// using one of the methods described above
			TransactionManager tm = getTransactionManager();

			// suspend transaction
			// suspend() returns reference to suspended
			// Transaction object which later should be passed
			// to resume()
			Transaction transaction = tm.suspend();
							
			// here you can do something outside of transaction
			// or start new transaction, 
			// do something and then commit or rollback
			userTransaction.begin();
				
			// commit subtransaction
			userTransaction.commit();

			// resume suspended transaction
			tm.resume(transaction);

			// commit first transaction
			userTransaction.commit();



@TransactionAttribute(value= TransactionAttributeType.REQUIRED)


sqlSession.flushStatements();
 sqlSession.commit();

+CreateDataBaseHandler.java
+CreateDocsHandler.java
GetDocsCountHandler.java
GetDocsPageHandler.java
RenameDocHandler.java


String sql = "INSERT INTO tbl (col) VALUES (?)";
preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
preparedStatement.setString(1, col);
preparedStatement.executeUpdate();
generatedKeys = preparedStatement.getGeneratedKeys();
if (generatedKeys.next()) {
    long id = generatedKeys.getLong(1);
} else {
    // Throw exception?
}


Ctrl+Shift+M

border: 1px solid #DDDDDD;
    border-radius: 15px 15px 15px 15px;


servlet_jdbc.storage

CREATE TABLE IF NOT EXISTS mind_data_users (
  id INT NOT NULL ,
  email VARCHAR(${emailSize}) NOT NULL UNIQUE,
  password VARCHAR(${passwordSize}) NOT NULL,
  name VARCHAR(${nameSize}) NOT NULL,
  
  PRIMARY KEY (id)
);

CREATE INDEX mind_data_users_email_index ON mind_data_users(email);


CREATE SEQUENCE IF NOT EXISTS mind_data_users_seq START WITH 1 INCREMENT BY 1;

		
ds.setUser(config.getInitParameter("db-user"));
ds.setPassword(config.getInitParameter("db-password"));
ds.setDriverClassName(config.getInitParameter("db-driver"));
ds.setUrl(config.getInitParameter("db-url"));
ds.setPoolSize(Integer.parseInt(config.getInitParameter("db-pool-size")));