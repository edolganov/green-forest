<html>
<body>

<h1>Знакомство с Green-forest Framework</h1>
<p>
Хочу рассказать Java-сообществу Хабра о небольшом, но очень полезном (на личном опыте) фреймворке 
под названием <a target="_blank" href='http://code.google.com/p/green-forest'>Green-forest</a>. Данный фреймворк можно 
использовать как самостоятельно, так и в контексте JEE или Spring. Как с помощью него упрощается 
и структурируется код приложения, можно узнать под катом.

<p>В начале рассмотрим проблему для решения которой предназначен Green-forest.

<h2>Проблема</h2>
<p>Очень часто архитектура крупного проекта имеет следующий вид:
<ul>
<li>Слой представления</li>
<li>Бизнес-слой</li>
<li>Слой работы с данными</li>
</ul>

<p>При этом бизнес-слой и слой данных состоят из классов-сервисов, предоставляющих внешнему миру публичное API. 
<br>Пример такого сервиса:
<pre>
public interface UserService {
	
	User createUser(Object someData);
	
	void activateUser(long id);
	
	User updateUser(User updatedUser);
	
	void blockUser(long id);
	
	void unblockUser(long id);

}
</pre>

<p>С ростом приложения растет количество методов в подобных сервисах - а значит растет громоздкость класса-реализации:
<pre>
public class UserServiceImpl implements UserService {

	//метод на 1-ой строке класса
	public User createUser(Object someData) {
		//реализация на 10-15 строк
	}

	//метод 16-ой страке класса
	public void activateUser(long id) {
		//реализация на 10-15 строк
	}

	//и т.д.

	//метод на 1000-ой строке класса
	public void unblockUser(long id) {
		//реализация на 10-15 строк
	}

}
</pre>

<p>В итоге появляются классы, содержащие десятки методов и 1000-ти строк кода. 
Искать и поддерживать код в таких класса становится трудно и муторно.

<h2>Классическое решение</h2>

<p>Очевидным решением видится разделение одного большого сервиса на множество более мелких:
<pre>
public interface UserBasicService {
	
	User createUser(Object someData);
	
	void activateUser(long id);
	
	User updateUser(User updatedUser);

}

public interface UserModerationService {
	
	void blockUser(long id);
	
	void unblockUser(long id);

}</pre>

<p>Однако, помимо простоты такой подход имеет ряд недостатков:
<br>— <b>Трудность равномерного разделения</b>: часто бывает трудно разделить сервис на равные части. 
В одном новом сервисе остается 3 метода, в другом - 10-ть.
<br>— <b>Неоднозначность разделения</b>: бывает трудно определить в какой дочерний сервис перенести 
конкретный метод. В результате методы переносятся нелогично и API усложняется для понимания.
<br>— <b>Устранение симптомов, но не причины:</b> по сути, мы не решили проблему, т.к. с ростом методов в новых сервисах
они тоже рискуют превратиться в громоздкие 1000-ти строчные реализации.

<p>Попробуем решить проблему громоздких сервисом в новом ключе.

<h2>Решение через атомарные функции</h2>
<p>Раз наше простое разделение сервиса на несколько ему подобных не дает полного решения проблемы, зададимся вопросом,
а можем ли мы разделить его на более атомариные сущности? Конечно же можем! Ведь целью любого сервиса являются его методы,
а значит, создав множество отдельных методов, мы избавися от озвученных выше недостатков:
<br>— <b>Нет проблем неравномерного и неоднозначного разделения</b>: множество методов разделено равномерно 
и однозначно по своему определению.
<br>— <b>Решена проблема роста:</b> с необходимостью новых методов - мы просто создаем новые классы, не увеличивая размер старых.

<h2>Реализация решения в Green-forest</h2>



































</body>
</html>